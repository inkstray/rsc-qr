//go:build ignore

/*
usage:
	go run maketables.go >jis2080.go
*/
package main

import (
	"bufio"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
	"unicode"
)

func main() {
	const url = "http://encoding.spec.whatwg.org/index-jis0208.txt"
	res, err := http.Get(url)
	if err != nil {
		log.Fatalf("%q: Get: %v", url, err)
	}
	defer res.Body.Close()
	var mapping [65536]bool
	scanner := bufio.NewScanner(res.Body)
	for scanner.Scan() {
		s := strings.TrimSpace(scanner.Text())
		if s == "" || s[0] == '#' {
			continue
		}
		f := strings.Fields(s)
		if len(f) < 2 {
			continue
		}
		n, err := strconv.ParseUint(f[1], 0, 16)
		if err != nil {
			continue
		}
		mapping[n] = true
	}
	if scanner.Err() != nil {
		log.Fatalln(scanner.Err())
	}
	var (
		start int
		in    bool
		r16   = make([]unicode.Range16, 0, 5120)
	)
	for i, v := range mapping {
		switch v {
		case in:
		case true:
			start = i
		default:
			r16 = append(r16, unicode.Range16{
				Lo:     uint16(start),
				Hi:     uint16(i - 1),
				Stride: 1,
			})
		}
		in = v
	}
	// Compact 1 item ranges.  This eliminates over 26% of the ranges.
	for i := 0; i < len(r16); i++ {
		if r16[i].Hi == r16[i].Lo && r16[i+1].Hi == r16[i+1].Lo &&
			r16[i+1].Hi-r16[i].Hi <= 0x4100 {
			r16[i].Hi = r16[i+1].Hi
			r16[i].Stride = r16[i].Hi - r16[i].Lo
			r16[i+1] = unicode.Range16{}
			j := i + 2
			for r16[j].Hi == r16[j].Lo &&
				r16[j].Hi == r16[i].Hi+r16[i].Stride {
				r16[i].Hi = r16[j].Hi
				r16[j] = unicode.Range16{}
				j++
			}
			i = j - 1
		}
	}
	fmt.Print(`// generated by go run maketables.go; DO NOT EDIT

package qr

import (
	"unicode"

	"golang.org/x/text/runes"
)

var jis0208 = runes.In(&unicode.RangeTable{
	R16: []unicode.Range16{
`)
	var latin int
	for _, v := range r16 {
		if v.Stride != 0 {
			fmt.Printf("\t\t{%#04x, %#04x, %d},\n",
				v.Lo, v.Hi, v.Stride)
			if v.Hi <= unicode.MaxLatin1 {
				latin++
			}
		}
	}
	fmt.Printf("\t},\n\tLatinOffset: %d,\n})\n", latin)
}
